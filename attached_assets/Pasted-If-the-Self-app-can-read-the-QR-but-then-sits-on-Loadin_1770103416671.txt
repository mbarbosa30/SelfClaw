If the Self app **can read the QR** but then sits on **Loading… forever**, that almost always means:

* the app successfully decoded your `SelfApp` config, **but can’t complete the verification step** (send proof to your endpoint / interact with your contract), or
* there’s a **config mismatch** (scope/config/endpoint type) that prevents the hub/backend from accepting the proof.

Here’s the most common culprits, in the order I’d hunt them down.

---

## 1) EndpointType vs endpoint mismatch (the #1 “infinite spinner” cause)

Self is strict about matching these two: ([docs.self.xyz][1])

* `endpointType: celo` → `endpoint` must be a **Celo mainnet contract address**
* `endpointType: celo-staging` → `endpoint` must be a **Celo Sepolia contract address**
* `endpointType: https` → `endpoint` must be an **HTTP(S) URL**
* `endpointType: https-staging` → also HTTP(S), used for **mock docs**

If you configured “onchain” but are actually using an HTTPS callback (or vice versa), the app often can’t finalize, and you’ll see the “loading purgatory”. ([docs.self.xyz][1])

**Quick test:** log/observe whether *anything* hits your backend when you scan.

* If **nothing** hits your server, your QR is probably pointing to an onchain endpoint (or a wrong URL), or the endpoint is unreachable.

---

## 2) Wrong network or mock/real mismatch

If you’re using **mock passports** but your endpoint is pointing to **Celo mainnet**, Self calls out “Invalid config ID” as a common result. ([docs.self.xyz][1])

Rule of thumb:

* mock docs → use the **staging** endpoint types + **Sepolia** (Celo Sepolia)
* real passports → use the **non-staging** endpoint types + correct production setup

This mismatch can present as a failure after scan.

---

## 3) Scope mismatch (frontend vs backend/contract)

If your frontend QR encodes `scope = X` but your backend verifier or contract expects the `scopeSeed = Y`, verification won’t complete. ([docs.self.xyz][1])

Self’s troubleshooting page explicitly says to ensure:

* `SelfAppBuilder.scope` equals your contract deployment `scopeSeed` (if onchain), and
* the endpoint (when a contract address) is **lowercase / non-checksum** in the builder. ([docs.self.xyz][1])

That “lowercase address” detail is sneaky and surprisingly common.

---

## 4) Your endpoint is unreachable from the phone (backend mode)

If `endpointType: https` (backend verification), the Self app has to POST proof data to your endpoint.

Common reasons it “loads forever”:

* your endpoint is `localhost` / private network / VPN-only
* Cloudflare/WAF is challenging or blocking mobile app requests
* TLS/certificate problems
* endpoint is slow or timing out
* your server returns a non-200 or unexpected body and the app doesn’t surface it nicely

**Quick test:** open the endpoint URL in the phone browser. If it doesn’t load instantly (or gets blocked), fix that first.

---

## 5) V2 config / disclosures mismatch or bad context encoding

If you’re on Self v2, frontend + backend/contract must agree on the verification config. Self documents “Config Mismatch” as a common issue. ([docs.self.xyz][1])

Also, Self flags “Invalid user context data” as a common migration issue: context often must be **properly hex encoded**. ([docs.self.xyz][2])

If you pass `userDefinedData` / `userContextData` incorrectly, the proof can fail validation after scan.

---

## 6) Onchain mode: contract errors (“execution reverted”)

If you’re verifying onchain, a bad hub address or a failing `customVerificationHook` can revert. Self lists a generic `-32000 execution reverted` bucket and suggests checking Hub address and your hook logic. ([docs.self.xyz][1])

This can also appear as “loading forever” from the user’s point of view.

---

# The fastest debugging loop (5 minutes, no guessing)

### A) Confirm what your QR is encoding

Scan the QR with the normal camera app and see:

* Is it a Self universal link?
* Does it contain the correct `endpointType` + `endpoint` + `scope`?

(If you’re using the Self QRCode SDK, it’s built from `SelfAppBuilder`, so check those values.) ([docs.self.xyz][3])

### B) Turn on `onError` in your QR component and print everything

Self’s QRCode SDK expects you to pass `onSuccess` and `onError`. Surface that error in the UI and console. ([docs.self.xyz][3])
Often the web side will tell you what the mobile UI doesn’t.

### C) Watch your server logs / chain

* backend mode: do you see a POST from the Self app?
* onchain mode: do you see a transaction attempt / revert?

No traffic = endpoint reachability / endpointType mismatch.
Traffic + failure = scope/config/context/hook issues.

---

## Two practical tips that also help UX

* If users are on mobile web, prefer **deeplinks** instead of QR scanning (less friction). ([docs.self.xyz][4])
* Add a “Having trouble?” panel that prints the current `scope`, `endpointType`, and `endpoint` so you can instantly spot mismatches.

---

If you paste just these three values from your `SelfAppBuilder` (scope, endpointType, endpoint) and tell me whether you’re doing **backend verification** or **onchain**, I can point to the most likely exact fix in one shot.

[1]: https://docs.self.xyz/use-self/troubleshooting?utm_source=chatgpt.com "Troubleshooting | Self Docs"
[2]: https://docs.self.xyz/use-self/migration-v1-v2?utm_source=chatgpt.com "V1 to V2 Migration Guide | Self Docs"
[3]: https://docs.self.xyz/frontend-integration/qrcode-sdk?utm_source=chatgpt.com "QRCode SDK | Self Docs"
[4]: https://docs.self.xyz/use-self/use-deeplinking?utm_source=chatgpt.com "Use deeplinking | Self Docs"
