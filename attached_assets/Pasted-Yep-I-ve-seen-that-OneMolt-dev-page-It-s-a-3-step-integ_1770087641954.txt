Yep, I’ve seen that OneMolt dev page. It’s a 3-step integration:

1. ask the agent (the “molt”) to sign a **unique challenge** with its **Ed25519** key
2. **verify the signature** against the claimed public key
3. call `GET /api/v1/molt/{publicKey}` to check if that key is registered with **World ID** backing ([OneMolt][1])

To build “OneMolt, but powered by Self”, you keep steps **1 + 2 exactly the same**, and you replace step **3** with **your own Self-backed registry** (API and/or smart contract) that performs Self verification and stores the binding.

Below is the step-by-step of what you’d need.

---

## Step-by-step implementation for a Self-backed “agent registry”

### Step 1: Keep the agent identity model (same as OneMolt)

* Every agent has an **Ed25519 keypair**.
* Your app generates a challenge like `{ action, timestamp, nonce, domain }`.
* Agent signs the JSON string.
* Your app verifies with Ed25519 before anything else. ([OneMolt][1])

**Why:** this proves the agent controls the private key, and prevents someone from registering random public keys.

---

### Step 2: Create the “Register agent” verification flow with Self (QR based)

Self’s “Quickstart” pattern is:

* frontend shows a **QR code** requesting a proof
* you verify either in your **backend** or **onchain** ([docs.self.xyz][2])

On the frontend you’ll:

* use `@selfxyz/qrcode` + `@selfxyz/core` to generate/display a QR request ([docs.self.xyz][2])
* include your **scope** and your verification **endpoint**
* include a **userContextData** blob that ties the Self proof request to the agent key + challenge (more on binding below)

---

### Step 3: Choose your verification mode (Backend MVP vs Onchain primitive)

#### Option A: Backend verification (fastest MVP)

On your server you instantiate `SelfBackendVerifier` with:

* `scope` (your app identifier, must match what the proof was generated for)
* `endpoint` (your public verification endpoint URL)
* `mockPassport` true/false (testnet vs mainnet)
* allowed attestation IDs (doc types)
* config store (rules like minAge/excludedCountries/OFAC)
* user id type (uuid or hex) ([docs.self.xyz][3])

Then your backend endpoint receives proof payload fields including:

* `attestationId`
* `proof`
* `pubSignals`
* `userContextData` ([docs.self.xyz][4])

…and returns a `VerificationResult` you can store.

This backend path has a trust assumption (users trust your server verifies correctly). Self calls that out explicitly. ([docs.self.xyz][2])

#### Option B: Onchain verification (strongest, “public registry”)

Self’s contract flow is:

1. your contract calls/implements `verifySelfProof(bytes proofPayload, bytes userContextData)`
2. the Hub verifies and calls you back on `onVerificationSuccess(bytes output, bytes userData)`
3. you implement your custom logic in the hook ([docs.self.xyz][5])

You’ll inherit `SelfVerificationRoot` from `@selfxyz/contracts`. ([docs.self.xyz][5])
And you’ll point to the deployed Hub address (Celo mainnet/testnet are listed in docs). ([docs.self.xyz][6])

---

### Step 4: The crucial glue: bind “Self human” ↔ “agent public key”

This is where most “looks fine in a demo, breaks in production” bugs live.

You want to prevent:

* replaying an old proof
* using a proof generated for agent A to register agent B
* registering an agent key you don’t control

**Binding recipe that works well:**

1. Your challenge includes `nonce`, `timestamp`, `domain`, and `agentPublicKey` (or a hash of it). (Same idea as OneMolt’s unique challenge guidance.) ([OneMolt][1])
2. The agent signs that challenge.
3. Your Self QR request includes `userContextData` that contains:

   * the same `nonce`
   * `agentPublicKeyHash`
   * maybe an expiry
4. When verifying the Self proof (backend or contract), you verify:

   * the Ed25519 signature is valid for the challenge
   * the `userContextData` matches the challenge nonce + agent key hash
   * the proof is valid for your `scope`/config (Self verifier checks scope/config match; it also expects hex-encoded context data). ([docs.self.xyz][4])

That binds the human proof to the exact agent key and exact moment.

---

### Step 5: Build your registry (the replacement for `GET /api/v1/molt/{publicKey}`)

OneMolt’s API returns a simple status plus `humanId` and verification metadata. ([OneMolt][1])
You’ll implement the same shape, but with a Self section.

**Minimum you store**

* `agentPublicKey` (or hash)
* `selfUserId` (your “humanId equivalent” from verification result; choose UUID or hex) ([docs.self.xyz][4])
* `registeredAt`
* `attestationId` / “assurance level” concept (optional)
* `configId` / rules version (optional)

**Recommended endpoints**

* `GET /api/v1/agent/{publicKey}` → `{ verified, publicKey, self: { verified, userId, attestationId, registeredAt } }`
* `GET /api/v1/human/{userId}` → list agents in that “swarm” (OneMolt calls this swarm tracking by `humanId`). ([OneMolt][1])

If you go onchain, this becomes:

* contract mapping `agentKeyHash → userIdHash/nullifier`
* plus an indexer/API for fast reads.

---

### Step 6: Handle re-verification and key lifecycle

OneMolt explicitly recommends re-verification with a fresh proof to “update human backing”. ([OneMolt][1])
You should implement:

* **re-verify** same agent key (updates timestamp / assurance)
* **key rotation** (optional): allow a verified human to migrate from old agent key → new agent key
* **revocation** (optional): mark agent key as revoked (compromised agent)

---

## What you should “consider” before you code (the short list)

* **What “verified” means** in your product: unique human, real-doc human, or policy-gated (age/country/OFAC). Self supports configurable rules via its config store. ([docs.self.xyz][3])
* **Privacy minimization**: store only a stable opaque identifier + timestamps, not disclosed attributes.
* **Trust level**: backend MVP is quickest; onchain registry is the “public primitive” route. ([docs.self.xyz][2])
* **Binding correctness**: treat `userContextData` + signature challenge as sacred plumbing.

---

If you want, I can write you a concrete “Selfclaw v1” spec that mirrors the OneMolt steps exactly (challenge format, `userContextData` encoding plan, API schema, and either backend-only or onchain-first architecture).

[1]: https://www.onemolt.ai/developers "Developer Docs | OneMolt"
[2]: https://docs.self.xyz/use-self/quickstart "Quickstart | Self Docs"
[3]: https://docs.self.xyz/backend-integration/basic-integration "Basic Integration | Self Docs"
[4]: https://docs.self.xyz/backend-integration/selfbackendverifier-api-reference "SelfBackendVerifier - API Reference | Self Docs"
[5]: https://docs.self.xyz/contract-integration/basic-integration "Basic Integration | Self Docs"
[6]: https://docs.self.xyz/contract-integration/deployed-contracts "Deployed Contracts | Self Docs"
